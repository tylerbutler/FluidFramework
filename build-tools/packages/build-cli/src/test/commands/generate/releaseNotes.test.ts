/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { readFile, unlink, writeFile } from "node:fs/promises";
import path from "node:path";
import { confirm } from "@inquirer/prompts";
import { runCommand } from "@oclif/test";
import { expect } from "chai";
import { afterEach, describe, it } from "mocha";

import { testDataPath, testRepoRoot } from "../../init.js";

const snapshotsDir = path.resolve(testDataPath, "releaseNotes/snapshots");

/**
 * Helper function to test snapshot matching for release notes
 */
async function testSnapshotMatch(
	outputContent: string,
	snapshotName: string,
	errorMessage: string = "Generated release notes do not match snapshot",
): Promise<void> {
	const snapshotFile = path.join(snapshotsDir, snapshotName);

	let expectedContent: string;
	try {
		expectedContent = await readFile(snapshotFile, "utf8");
	} catch {
		// If snapshot doesn't exist, create it
		await writeFile(snapshotFile, outputContent, "utf8");
		console.log(`Created new snapshot: ${snapshotFile}`);
		return;
	}

	// Normalize line endings for cross-platform compatibility
	const normalizeContent = (content: string): string => content.replace(/\r\n/g, "\n").trim();

	const normalizedOutput = normalizeContent(outputContent);
	const normalizedExpected = normalizeContent(expectedContent);

	if (normalizedOutput !== normalizedExpected) {
		// Write the actual output to a file for easy comparison
		const actualFile = path.join(snapshotsDir, snapshotName.replace(".md", ".actual.md"));
		await writeFile(actualFile, outputContent, "utf8");

		console.log(`Snapshot mismatch detected.`);

		const proceed = await confirm({
			message: `Update snapshots?`,
		});
		if (proceed !== true) {
			await writeFile(actualFile, outputContent, "utf8");
			return;
		}

		console.log(`Expected: ${snapshotFile}`);
		console.log(`Actual: ${actualFile}`);
		console.log(
			`To update snapshot, replace the contents of the expected file with the actual file.`,
		);
	}

	expect(normalizedOutput).to.equal(
		normalizedExpected,
		`${errorMessage}. Check the .actual.md file for differences.`,
	);
}

describe.only("generate:releaseNotes", () => {
	const testOutputFile = path.join(testDataPath, "TEST_RELEASE_NOTES.md");

	afterEach(async () => {
		// Clean up test output file
		try {
			await unlink(testOutputFile);
		} catch {
			// Ignore if file doesn't exist
		}
	});

	// it("generates release notes with correct mdast structure", async () => {
	// 	await runCommand(
	// 		[
	// 			"generate:releaseNotes",
	// 			"--releaseGroup",
	// 			"main",
	// 			"--releaseType",
	// 			"minor",
	// 			"--outFile",
	// 			"TEST_RELEASE_NOTES.md",
	// 		],
	// 		{
	// 			root: import.meta.url,
	// 		},
	// 	);

	// 	// Verify the file was created
	// 	const outputContent = await readFile(testOutputFile, "utf8");
	// 	expect(outputContent).to.not.be.empty;

	// 	// Parse the markdown to verify mdast structure
	// 	const mdastTree = fromMarkdown(outputContent);

	// 	// Check that we have a proper root node
	// 	expect(mdastTree.type).to.equal("root");
	// 	expect(mdastTree.children).to.not.be.empty;

	// 	// Verify HTML comment is first
	// 	const firstChild = mdastTree.children[0];
	// 	expect(firstChild?.type).to.equal("html");
	// 	expect((firstChild as Html).value).to.include("THIS IS AN AUTOGENERATED FILE");

	// 	// Verify main heading exists
	// 	let hasMainHeading = false;
	// 	let hasContentsHeading = false;
	// 	let hasSectionHeadings = false;
	// 	let hasChangeDetails = false;
	// 	let hasTocLinks = false;

	// 	visit(mdastTree, "heading", (node: Heading) => {
	// 		if (node.depth === 1 && node.children[0]?.type === "text") {
	// 			const text = node.children[0].value;
	// 			if (text.includes("Fluid Framework v")) {
	// 				hasMainHeading = true;
	// 			}
	// 		}
	// 		if (node.depth === 2 && node.children[0]?.type === "text") {
	// 			const text = node.children[0].value;
	// 			if (text === "Contents") {
	// 				hasContentsHeading = true;
	// 			}
	// 			if (text === "ðŸš€ New Features" || text === "ðŸ› Bug Fixes") {
	// 				hasSectionHeadings = true;
	// 			}
	// 		}
	// 		if (node.depth === 4 && node.children[0]?.type === "text") {
	// 			const text = node.children[0].value;
	// 			if (text === "Change details") {
	// 				hasChangeDetails = true;
	// 			}
	// 		}
	// 	});

	// 	visit(mdastTree, "link", (node: Link) => {
	// 		if (node.url === "#contents" && node.children[0]?.type === "text") {
	// 			const text = node.children[0].value;
	// 			if (text === "â¬†ï¸ Table of contents") {
	// 				hasTocLinks = true;
	// 			}
	// 		}
	// 	});

	// 	expect(hasMainHeading).to.be.true;
	// 	expect(hasContentsHeading).to.be.true;
	// 	expect(hasSectionHeadings).to.be.true;
	// 	expect(hasChangeDetails).to.be.true;
	// 	expect(hasTocLinks).to.be.true;
	// });

	// it("excludes H1 heading when --excludeH1 flag is used", async () => {
	// 	await runCommand(
	// 		[
	// 			"generate:releaseNotes",
	// 			"--releaseGroup",
	// 			"main",
	// 			"--releaseType",
	// 			"minor",
	// 			"--outFile",
	// 			"TEST_RELEASE_NOTES.md",
	// 			"--excludeH1",
	// 		],
	// 		{
	// 			root: import.meta.url,
	// 		},
	// 	);

	// 	const outputContent = await readFile(testOutputFile, "utf8");
	// 	const mdastTree = fromMarkdown(outputContent);

	// 	let hasMainHeading = false;
	// 	visit(mdastTree, "heading", (node: Heading) => {
	// 		if (node.depth === 1) {
	// 			hasMainHeading = true;
	// 		}
	// 	});

	// 	expect(hasMainHeading).to.be.false;
	// });

	// it("includes heading links when --headingLinks flag is used", async () => {
	// 	await runCommand(
	// 		[
	// 			"generate:releaseNotes",
	// 			"--releaseGroup",
	// 			"main",
	// 			"--releaseType",
	// 			"minor",
	// 			"--outFile",
	// 			"TEST_RELEASE_NOTES.md",
	// 			"--headingLinks",
	// 		],
	// 		{
	// 			root: import.meta.url,
	// 		},
	// 	);

	// 	const outputContent = await readFile(testOutputFile, "utf8");
	// 	const mdastTree = fromMarkdown(outputContent);

	// 	let hasHeadingLinks = false;
	// 	let hasUserContentLinks = false;

	// 	visit(mdastTree, "heading", (node: Heading) => {
	// 		if (node.children.length > 0 && node.children[0]?.type === "html") {
	// 			const htmlNode = node.children[0];
	// 			if (htmlNode.value.includes('<a id="')) {
	// 				hasHeadingLinks = true;
	// 			}
	// 		}
	// 	});

	// 	visit(mdastTree, "link", (node: Link) => {
	// 		if (node.url.includes("user-content-")) {
	// 			hasUserContentLinks = true;
	// 		}
	// 	});

	// 	expect(hasHeadingLinks).to.be.true;
	// 	expect(hasUserContentLinks).to.be.true;
	// });

	// it("properly structures sections and change details", async () => {
	// 	await runCommand(
	// 		[
	// 			"generate:releaseNotes",
	// 			"--releaseGroup",
	// 			"main",
	// 			"--releaseType",
	// 			"minor",
	// 			"--outFile",
	// 			"TEST_RELEASE_NOTES.md",
	// 		],
	// 		{
	// 			root: import.meta.url,
	// 		},
	// 	);

	// 	const outputContent = await readFile(testOutputFile, "utf8");
	// 	const mdastTree = fromMarkdown(outputContent);

	// 	// Verify the structure includes expected sections
	// 	let foundFeatureSection = false;
	// 	let foundFixSection = false;
	// 	let foundChangeTitle = false;
	// 	let foundAffectedPackages = false;

	// 	visit(mdastTree, "heading", (node: Heading) => {
	// 		if (node.children[0]?.type === "text") {
	// 			const text = node.children[0].value;
	// 			if (text === "ðŸš€ New Features") {
	// 				foundFeatureSection = true;
	// 			}
	// 			if (text === "ðŸ› Bug Fixes") {
	// 				foundFixSection = true;
	// 			}
	// 			if (text.includes("Add new feature support")) {
	// 				foundChangeTitle = true;
	// 			}
	// 		}
	// 	});

	// 	visit(mdastTree, "paragraph", (node: Paragraph) => {
	// 		if (node.children[0]?.type === "text") {
	// 			const text = node.children[0].value;
	// 			if (text === "Affected packages:") {
	// 				foundAffectedPackages = true;
	// 			}
	// 		}
	// 	});

	// 	expect(foundFeatureSection).to.be.true;
	// 	expect(foundFixSection).to.be.true;
	// 	expect(foundChangeTitle).to.be.true;
	// 	expect(foundAffectedPackages).to.be.true;
	// });

	// it("includes footer section", async () => {
	// 	await runCommand(
	// 		[
	// 			"generate:releaseNotes",
	// 			"--releaseGroup",
	// 			"main",
	// 			"--releaseType",
	// 			"minor",
	// 			"--outFile",
	// 			"TEST_RELEASE_NOTES.md",
	// 		],
	// 		{
	// 			root: import.meta.url,
	// 		},
	// 	);

	// 	const outputContent = await readFile(testOutputFile, "utf8");
	// 	const mdastTree = fromMarkdown(outputContent);

	// 	let hasStartBuildingHeading = false;
	// 	let hasGitHubLinks = false;

	// 	visit(mdastTree, "heading", (node: Heading) => {
	// 		if (node.children[0]?.type === "text") {
	// 			const text = node.children[0].value;
	// 			if (text.includes("Start Building Today")) {
	// 				hasStartBuildingHeading = true;
	// 			}
	// 		}
	// 	});

	// 	visit(mdastTree, "link", (node: Link) => {
	// 		if (node.url.includes("github.com/microsoft/FluidFramework")) {
	// 			hasGitHubLinks = true;
	// 		}
	// 	});

	// 	expect(hasStartBuildingHeading).to.be.true;
	// 	expect(hasGitHubLinks).to.be.true;
	// });

	// it("generates valid markdown that can be parsed", async () => {
	// 	await runCommand(
	// 		[
	// 			"generate:releaseNotes",
	// 			"--releaseGroup",
	// 			"main",
	// 			"--releaseType",
	// 			"minor",
	// 			"--outFile",
	// 			"TEST_RELEASE_NOTES.md",
	// 		],
	// 		{
	// 			root: import.meta.url,
	// 		},
	// 	);

	// 	const outputContent = await readFile(testOutputFile, "utf8");

	// 	// Verify the markdown can be parsed without errors
	// 	expect(() => fromMarkdown(outputContent)).to.not.throw();

	// 	// Verify basic markdown structure
	// 	expect(outputContent).to.include("# Fluid Framework v");
	// 	expect(outputContent).to.include("## Contents");
	// 	expect(outputContent).to.include("ðŸš€ New Features");
	// 	expect(outputContent).to.include("ðŸ› Bug Fixes");
	// 	expect(outputContent).to.include("### Add new feature support");
	// 	expect(outputContent).to.include("#### Change details");
	// 	expect(outputContent).to.include("Affected packages:");
	// 	expect(outputContent).to.include("â¬†ï¸ Table of contents");
	// 	expect(outputContent).to.include("ðŸ› ï¸ Start Building Today!");
	// });

	// it("includes table of contents with proper links", async () => {
	// 	await runCommand(
	// 		[
	// 			"generate:releaseNotes",
	// 			"--releaseGroup",
	// 			"main",
	// 			"--releaseType",
	// 			"minor",
	// 			"--outFile",
	// 			"TEST_RELEASE_NOTES.md",
	// 		],
	// 		{
	// 			root: import.meta.url,
	// 		},
	// 	);

	// 	const outputContent = await readFile(testOutputFile, "utf8");

	// 	// The remark-toc plugin should generate a TOC after the "Contents" heading
	// 	expect(outputContent).to.include("## Contents");

	// 	// Should contain links to the main sections
	// 	expect(outputContent).to.match(/- \[.*New Features.*]\(#.*\)/);
	// 	expect(outputContent).to.match(/- \[.*Bug Fixes.*]\(#.*\)/);
	// });

	it.only("matches snapshot for consistent output format", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
				"--changesetPath",
				path.join(testDataPath, ".changeset"),
				"--root",
				testRepoRoot,
			],
			{
				root: import.meta.url,
			},
		);

		let outputContent: string = "";
		try {
			outputContent = await readFile(testOutputFile, "utf8");
		} catch {
			// do nothing
		}
		await testSnapshotMatch(
			outputContent,
			"main-minor-release-notes.md",
			"Generated release notes do not match snapshot",
		);
	});

	it("matches snapshot with headingLinks flag", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
				"--headingLinks",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf8");
		await testSnapshotMatch(
			outputContent,
			"main-minor-release-notes-with-heading-links.md",
			"Generated release notes with heading links do not match snapshot",
		);
	});

	it("matches snapshot with excludeH1 flag", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
				"--excludeH1",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf8");
		await testSnapshotMatch(
			outputContent,
			"main-minor-release-notes-exclude-h1.md",
			"Generated release notes without H1 do not match snapshot",
		);
	});
});
