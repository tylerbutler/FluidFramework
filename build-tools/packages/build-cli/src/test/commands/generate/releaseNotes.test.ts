/*!
 * Copyright (c) Microsoft Corporation and contributors. All rights reserved.
 * Licensed under the MIT License.
 */

import { readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { runCommand } from "@oclif/test";
import { expect } from "chai";
import type { Heading, Html, Link, Paragraph, Root, Text } from "mdast";
import { fromMarkdown } from "mdast-util-from-markdown";
import { afterEach, beforeEach, describe, it } from "mocha";
import { visit } from "unist-util-visit";

import { testRepoRoot } from "../../init.js";

describe("generate:releaseNotes", () => {
	const testOutputFile = path.join(testRepoRoot, "TEST_RELEASE_NOTES.md");

	afterEach(async () => {
		// Clean up test output file
		try {
			await import("node:fs/promises").then((fs) => fs.unlink(testOutputFile));
		} catch {
			// Ignore if file doesn't exist
		}
	});

	it("generates release notes with correct mdast structure", async () => {
		const { stdout } = await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
			],
			{
				root: import.meta.url,
			},
		);

		// Verify the file was created
		const outputContent = await readFile(testOutputFile, "utf-8");
		expect(outputContent).to.not.be.empty;

		// Parse the markdown to verify mdast structure
		const mdastTree = fromMarkdown(outputContent);

		// Check that we have a proper root node
		expect(mdastTree.type).to.equal("root");
		expect(mdastTree.children).to.not.be.empty;

		// Verify HTML comment is first
		const firstChild = mdastTree.children[0];
		expect(firstChild?.type).to.equal("html");
		expect((firstChild as Html).value).to.include("THIS IS AN AUTOGENERATED FILE");

		// Verify main heading exists
		let hasMainHeading = false;
		let hasContentsHeading = false;
		let hasSectionHeadings = false;
		let hasChangeDetails = false;
		let hasTocLinks = false;

		visit(mdastTree, "heading", (node: Heading) => {
			if (node.depth === 1 && node.children[0]?.type === "text") {
				const text = (node.children[0] as Text).value;
				if (text.includes("Fluid Framework v")) {
					hasMainHeading = true;
				}
			}
			if (node.depth === 2 && node.children[0]?.type === "text") {
				const text = (node.children[0] as Text).value;
				if (text === "Contents") {
					hasContentsHeading = true;
				}
				if (text === "ðŸš€ New Features" || text === "ðŸ› Bug Fixes") {
					hasSectionHeadings = true;
				}
			}
			if (node.depth === 4 && node.children[0]?.type === "text") {
				const text = (node.children[0] as Text).value;
				if (text === "Change details") {
					hasChangeDetails = true;
				}
			}
		});

		visit(mdastTree, "link", (node: Link) => {
			if (node.url === "#contents" && node.children[0]?.type === "text") {
				const text = (node.children[0] as Text).value;
				if (text === "â¬†ï¸ Table of contents") {
					hasTocLinks = true;
				}
			}
		});

		expect(hasMainHeading).to.be.true;
		expect(hasContentsHeading).to.be.true;
		expect(hasSectionHeadings).to.be.true;
		expect(hasChangeDetails).to.be.true;
		expect(hasTocLinks).to.be.true;
	});

	it("excludes H1 heading when --excludeH1 flag is used", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
				"--excludeH1",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf-8");
		const mdastTree = fromMarkdown(outputContent);

		let hasMainHeading = false;
		visit(mdastTree, "heading", (node: Heading) => {
			if (node.depth === 1) {
				hasMainHeading = true;
			}
		});

		expect(hasMainHeading).to.be.false;
	});

	it("includes heading links when --headingLinks flag is used", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
				"--headingLinks",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf-8");
		const mdastTree = fromMarkdown(outputContent);

		let hasHeadingLinks = false;
		let hasUserContentLinks = false;

		visit(mdastTree, "heading", (node: Heading) => {
			if (node.children.length > 0 && node.children[0]?.type === "html") {
				const htmlNode = node.children[0] as Html;
				if (htmlNode.value.includes('<a id="')) {
					hasHeadingLinks = true;
				}
			}
		});

		visit(mdastTree, "link", (node: Link) => {
			if (node.url.includes("user-content-")) {
				hasUserContentLinks = true;
			}
		});

		expect(hasHeadingLinks).to.be.true;
		expect(hasUserContentLinks).to.be.true;
	});

	it("properly structures sections and change details", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf-8");
		const mdastTree = fromMarkdown(outputContent);

		// Verify the structure includes expected sections
		let foundFeatureSection = false;
		let foundFixSection = false;
		let foundChangeTitle = false;
		let foundAffectedPackages = false;

		visit(mdastTree, "heading", (node: Heading) => {
			if (node.children[0]?.type === "text") {
				const text = (node.children[0] as Text).value;
				if (text === "ðŸš€ New Features") {
					foundFeatureSection = true;
				}
				if (text === "ðŸ› Bug Fixes") {
					foundFixSection = true;
				}
				if (text.includes("Add new feature support")) {
					foundChangeTitle = true;
				}
			}
		});

		visit(mdastTree, "paragraph", (node: Paragraph) => {
			if (node.children[0]?.type === "text") {
				const text = (node.children[0] as Text).value;
				if (text === "Affected packages:") {
					foundAffectedPackages = true;
				}
			}
		});

		expect(foundFeatureSection).to.be.true;
		expect(foundFixSection).to.be.true;
		expect(foundChangeTitle).to.be.true;
		expect(foundAffectedPackages).to.be.true;
	});

	it("includes footer section", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf-8");
		const mdastTree = fromMarkdown(outputContent);

		let hasStartBuildingHeading = false;
		let hasGitHubLinks = false;

		visit(mdastTree, "heading", (node: Heading) => {
			if (node.children[0]?.type === "text") {
				const text = (node.children[0] as Text).value;
				if (text.includes("Start Building Today")) {
					hasStartBuildingHeading = true;
				}
			}
		});

		visit(mdastTree, "link", (node: Link) => {
			if (node.url.includes("github.com/microsoft/FluidFramework")) {
				hasGitHubLinks = true;
			}
		});

		expect(hasStartBuildingHeading).to.be.true;
		expect(hasGitHubLinks).to.be.true;
	});

	it("generates valid markdown that can be parsed", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf-8");

		// Verify the markdown can be parsed without errors
		expect(() => fromMarkdown(outputContent)).to.not.throw();

		// Verify basic markdown structure
		expect(outputContent).to.include("# Fluid Framework v");
		expect(outputContent).to.include("## Contents");
		expect(outputContent).to.include("ðŸš€ New Features");
		expect(outputContent).to.include("ðŸ› Bug Fixes");
		expect(outputContent).to.include("### Add new feature support");
		expect(outputContent).to.include("#### Change details");
		expect(outputContent).to.include("Affected packages:");
		expect(outputContent).to.include("â¬†ï¸ Table of contents");
		expect(outputContent).to.include("ðŸ› ï¸ Start Building Today!");
	});

	it("includes table of contents with proper links", async () => {
		await runCommand(
			[
				"generate:releaseNotes",
				"--releaseGroup",
				"main",
				"--releaseType",
				"minor",
				"--outFile",
				"TEST_RELEASE_NOTES.md",
			],
			{
				root: import.meta.url,
			},
		);

		const outputContent = await readFile(testOutputFile, "utf-8");

		// The remark-toc plugin should generate a TOC after the "Contents" heading
		expect(outputContent).to.include("## Contents");

		// Should contain links to the main sections
		expect(outputContent).to.match(/- \[.*New Features.*\]\(#.*\)/);
		expect(outputContent).to.match(/- \[.*Bug Fixes.*\]\(#.*\)/);
	});
});
