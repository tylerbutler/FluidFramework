## API Report File for "@fluid-internal/sorted-btree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export class BTree<K = any, V = any> implements ISortedMapF<K, V>, ISortedMap<K, V> {
    constructor(entries?: [K, V][], compare?: (a: K, b: K) => number, maxNodeSize?: number);
    changeIfPresent(key: K, value: V): boolean;
    checkValid(): void;
    clear(): void;
    clone(): BTree<K, V>;
    _compare: (a: K, b: K) => number;
    delete(key: K): boolean;
    deleteKeys(keys: K[]): number;
    deleteRange(low: K, high: K, includeHigh: boolean): number;
    diffAgainst<R>(other: BTree<K, V>, onlyThis?: (k: K, v: V) => {
        break?: R;
    } | void, onlyOther?: (k: K, v: V) => {
        break?: R;
    } | void, different?: (k: K, vThis: V, vOther: V) => {
        break?: R;
    } | void): R | undefined;
    editAll<R = V>(onFound: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void, initialCounter?: number): R | number;
    editRange<R = V>(low: K, high: K, includeHigh: boolean, onFound: (k: K, v: V, counter: number) => EditRangeResult<V, R> | void, initialCounter?: number): R | number;
    entries(lowestKey?: K, reusedArray?: (K | V)[]): IterableIterator<[K, V]>;
    entriesReversed(highestKey?: K, reusedArray?: (K | V)[], skipHighest?: boolean): IterableIterator<[K, V]>;
    filter(callback: (k: K, v: V, counter: number) => boolean, returnThisIfUnchanged?: boolean): BTree<K, V>;
    // (undocumented)
    forEach(callback: (v: V, k: K, tree: BTree<K, V>) => void, thisArg?: any): number;
    forEachPair<R = number>(callback: (k: K, v: V, counter: number) => {
        break?: R;
    } | void, initialCounter?: number): R | number;
    // (undocumented)
    forRange(low: K, high: K, includeHigh: boolean, onFound?: (k: K, v: V, counter: number) => void, initialCounter?: number): number;
    freeze(): void;
    get(key: K, defaultValue?: V): V | undefined;
    getPairOrNextHigher(key: K, reusedArray?: [K, V]): [K, V] | undefined;
    getPairOrNextLower(key: K, reusedArray?: [K, V]): [K, V] | undefined;
    getRange(low: K, high: K, includeHigh?: boolean, maxLength?: number): [K, V][];
    greedyClone(force?: boolean): BTree<K, V>;
    has(key: K): boolean;
    get height(): number;
    get isEmpty(): boolean;
    get isFrozen(): boolean;
    keys(firstKey?: K): IterableIterator<K>;
    keysArray(): K[];
    get length(): number;
    mapValues<R>(callback: (v: V, k: K, counter: number) => R): BTree<K, R>;
    maxKey(): K | undefined;
    get maxNodeSize(): number;
    // (undocumented)
    _maxNodeSize: number;
    minKey(): K | undefined;
    nextHigherKey(key: K | undefined): K | undefined;
    nextHigherPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined;
    nextLowerKey(key: K | undefined): K | undefined;
    nextLowerPair(key: K | undefined, reusedArray?: [K, V]): [K, V] | undefined;
    reduce<R>(callback: (previous: R, currentPair: [K, V], counter: number, tree: BTree<K, V>) => R, initialValue: R): R;
    // (undocumented)
    reduce<R>(callback: (previous: R | undefined, currentPair: [K, V], counter: number, tree: BTree<K, V>) => R): R | undefined;
    set(key: K, value: V, overwrite?: boolean): boolean;
    setIfNotPresent(key: K, value: V): boolean;
    setPairs(pairs: [K, V][], overwrite?: boolean): number;
    get size(): number;
    // (undocumented)
    _size: number;
    toArray(maxLength?: number): [K, V][];
    toString(): string;
    unfreeze(): void;
    values(firstKey?: K): IterableIterator<V>;
    valuesArray(): V[];
    with(key: K): BTree<K, V | undefined>;
    with<V2>(key: K, value: V2, overwrite?: boolean): BTree<K, V | V2>;
    withKeys(keys: K[], returnThisIfUnchanged?: boolean): BTree<K, V | undefined>;
    without(key: K, returnThisIfUnchanged?: boolean): BTree<K, V>;
    withoutKeys(keys: K[], returnThisIfUnchanged?: boolean): BTree<K, V>;
    withoutRange(low: K, high: K, includeHigh: boolean, returnThisIfUnchanged?: boolean): BTree<K, V>;
    withPairs<V2>(pairs: [K, V | V2][], overwrite: boolean): BTree<K, V | V2>;
}

// @public (undocumented)
export type EditRangeResult<V, R = number> = {
    value?: V;
    break?: R;
    delete?: boolean;
};

// @public
export interface ISortedMap<K = any, V = any> extends IMap<K, V>, ISortedMapSource<K, V> {
    deleteKeys(keys: K[]): number;
    deleteRange(low: K, high: K, includeHigh: boolean): number;
    // (undocumented)
    entries(firstKey?: K): IterableIterator<[K, V]>;
    // (undocumented)
    keys(firstKey?: K): IterableIterator<K>;
    set(key: K, value: V, overwrite?: boolean): boolean;
    setPairs(pairs: [K, V][], overwrite?: boolean): number;
    // (undocumented)
    values(firstKey?: K): IterableIterator<V>;
}

// @public (undocumented)
export interface ISortedMapF<K = any, V = any> extends ISortedSetF<K>, IMapF<K, V>, ISortedMapSource<K, V> {
    // (undocumented)
    entries(firstKey?: K): IterableIterator<[K, V]>;
    // (undocumented)
    filter(callback: (k: K, v: any, counter: number) => boolean, returnThisIfUnchanged?: boolean): ISortedMapF<K, V>;
    // (undocumented)
    forRange(low: K, high: K, includeHigh: boolean, onFound?: (k: K, v: V, counter: number) => void, initialCounter?: number): number;
    // (undocumented)
    keys(firstKey?: K): IterableIterator<K>;
    // (undocumented)
    mapValues<R>(callback: (v: V, k: K, counter: number) => R): ISortedMapF<K, R>;
    // (undocumented)
    values(firstKey?: K): IterableIterator<V>;
    // (undocumented)
    with(key: K): ISortedMapF<K, V | undefined>;
    // (undocumented)
    with<V2>(key: K, value: V2, overwrite?: boolean): ISortedMapF<K, V | V2>;
    // (undocumented)
    withKeys(keys: K[], returnThisIfUnchanged?: boolean): ISortedMapF<K, V | undefined>;
    // (undocumented)
    without(key: K): ISortedMapF<K, V>;
    // (undocumented)
    withoutKeys(keys: K[], returnThisIfUnchanged?: boolean): ISortedMapF<K, V>;
    withoutRange(low: K, high: K, includeHigh: boolean, returnThisIfUnchanged?: boolean): ISortedMapF<K, V>;
    // (undocumented)
    withPairs<V2>(pairs: [K, V | V2][], overwrite: boolean): ISortedMapF<K, V | V2>;
}

// (No @packageDocumentation comment for this package)

```
