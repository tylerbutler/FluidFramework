================================================================================
FLUIDFRAMEWORK MONOREPO EXPLORATION SUMMARY
Bazel Migration Proof of Concept Analysis
October 27, 2025
================================================================================

PROJECT OVERVIEW
================================================================================

Project Name: FluidFramework (Microsoft)
Repository: https://github.com/microsoft/FluidFramework
Version: 2.70.0
Type: TypeScript Monorepo (pnpm workspaces)
Purpose: Distributed, real-time collaborative web applications framework

Size & Scope:
- Total Packages: 80+ (main client workspace)
- Main Client Packages: ~65
- Build Tools Packages: ~15
- Lines of Code: 500K+ TypeScript
- File Count: ~2000+ source files
- pnpm-lock.yaml: 1.5MB+


MONOREPO STRUCTURE
================================================================================

Top-Level Organization:
├── packages/          (65 client packages organized by category)
│   ├── common/        (5) - Core interfaces & utilities
│   ├── dds/           (16) - Distributed Data Structures
│   ├── drivers/       (4) - Storage & connectivity drivers
│   ├── framework/     (15+) - Framework implementations
│   ├── loader/        (5) - Loading infrastructure
│   ├── runtime/       (10+) - Runtime components
│   ├── service-clients/ (3+) - Service clients
│   ├── test/          (2) - Testing utilities
│   ├── tools/         (5) - Build & dev tools
│   └── utils/         (8+) - Utilities
├── azure/             - Azure-specific packages
├── examples/          - Example applications
├── experimental/      - Experimental features
├── build-tools/       - Build infrastructure (separate workspace)
├── server/            - Server-side (routerlicious)
└── docs/              - Documentation


CURRENT BUILD SYSTEM
================================================================================

System: fluid-build (custom TypeScript-aware build orchestrator)
Package Manager: pnpm 10.18.3 with workspaces
TypeScript Version: ~5.4.5 (strict mode)
Node.js Requirement: ≥20.15.1

Build Configuration:
- Root: fluidBuild.config.cjs (task definitions)
- Per-Package: fluidBuild.tasks in package.json
- Build Patterns: Consistent across all packages

Standard Build Flow:
  tsc (compile) → eslint (lint) → api-extractor → mocha/jest (test)

Dual Output Compilation:
- ESM Output: lib/ (browsers, bundlers)
- CJS Output: dist/ (Node.js)
- Both compiled from src/ → must be validated separately

Build Tasks (Root):
- ci:build - CI-grade build (compile, lint, checks)
- build - Full build with all validation
- build:compile - TypeScript compilation only
- build:esnext - ESM compilation
- clean - Clean all build artifacts
- test:mocha - Mocha test runner
- test:jest - Jest test runner
- lint - Full linting (eslint, good-fences, depcruise)
- webpack - Bundle generation

Build Scripts (Per-Package):
- build - Full package build
- build:esnext - ESM compilation (tsc)
- build:commonjs - CJS compilation (fluid-tsc)
- tsc - CommonJS output
- test - Run tests (mocha + jest)
- lint - Run linting
- clean - Remove artifacts


KEY TECHNOLOGICAL STACK
================================================================================

Language & Runtime:
- TypeScript 5.4.5 (strict mode, 100+ packages)
- JavaScript ES2020+
- Node.js 20.15.1+

Testing Frameworks:
- Mocha (primary test runner for unit tests)
- Jest (for UI/browser testing)
- c8 (code coverage)
- Puppeteer (browser automation)

Code Quality:
- ESLint ~8.57.1
- Biome ~1.9.3 (fast formatter)
- good-fences (architecture validation)
- dependency-cruiser (dep graph validation)

API & Documentation:
- Microsoft API-extractor (API reports)
- TypeScript API generation
- Breaking change detection

Build/Configuration:
- pnpm 10 with link-workspace-packages
- TypeScript compiler (tsc)
- fluid-tsc (custom wrapper)
- api-extractor (Microsoft)
- @fluid-tools/build-cli (flub)


DEPENDENCY GRAPH INSIGHTS
================================================================================

Package Dependency Layers (Bottom-Up):

FOUNDATION (Zero Dependencies):
- @fluidframework/core-interfaces
  └─ Only devDependencies (no production imports)

BASE LAYER (Minimal Dependencies):
- @fluidframework/driver-definitions
  └─ Depends: core-interfaces (workspace:~)
- @fluidframework/container-definitions
  └─ Depends: core-interfaces, driver-definitions

CORE UTILITIES:
- @fluidframework/core-utils
  └─ Only external utilities (events, uuid, etc.)

OTHER CATEGORIES:
- DDS packages (16 packages) - 8-12 dependencies each
- Framework packages (15+) - 5-8 dependencies each
- Runtime packages (10+) - 6-10 dependencies each
- Utils packages - 2-5 dependencies each

Interdependency Pattern: ALL use "workspace:~" for version coupling
External Dependencies: Locked via pnpm-lock.yaml (1.5MB)


TYPESCRIPT CONFIGURATION
================================================================================

Base Configuration:
- Extends: ../../../common/build/build-common/tsconfig.node16.json
- Strict Mode: Enabled
- Module: ESNext (lib/), CommonJS (dist/)
- Target: ES2020 or later

Per-Package Configs:
1. tsconfig.json - ESM compilation
   ├─ rootDir: src/
   └─ outDir: lib/

2. tsconfig.cjs.json - CommonJS compilation
   ├─ rootDir: src/
   └─ outDir: dist/

3. src/test/tsconfig.json - Test compilation
   └─ Includes test sources

4. src/test/tsconfig.no-exactOptionalPropertyTypes.json
   └─ Type compatibility testing


TEST INFRASTRUCTURE
================================================================================

Test Frameworks:
- Mocha: ESM & CJS variants
- Jest: Browser/UI testing
- c8: Coverage reporting

Test Execution:
- npm run test:mocha - Run mocha tests
- npm run test:jest - Run jest tests
- npm run build-and-test - Build + all tests
- npm run test:coverage - Generate coverage

Test Coverage:
- Source code: src/test/
  ├─ mocha/ - Mocha test files
  ├─ jest/ - Jest test files
  └─ types/ - Type validation tests
- Outputs: dist/test/, lib/test/
- Reports: nyc/ (coverage), benchmarkOutput/


QUALITY & LINTING
================================================================================

ESLint Configuration:
- Version: ~8.57.1
- Config: .eslintrc.cjs per package
- Scope: TypeScript & JavaScript files

Biome (Fast Formatter):
- Version: ~1.9.3
- Config: biome.jsonc
- Replaces Prettier + some ESLint rules

Architecture Validation:
- good-fences: Package boundary enforcement
- dependency-cruiser: Dep graph rules (.dependency-cruiser.cjs)
- Violations tracked: .dependency-cruiser-known-violations.json

API Validation:
- api-extractor: Generates .api.md files
- Public, legacy, internal exports tracked separately
- Breaking change detection


RECOMMENDED PoC PACKAGES (PRIORITY ORDER)
================================================================================

PHASE 1: FOUNDATION (2-3 hours)
-------------------------------------------

1. @fluidframework/core-interfaces ⭐ RECOMMENDED FIRST CHOICE
   Location: packages/common/core-interfaces
   Dependencies: NONE (only devDependencies)
   Size: ~500-1000 LOC (interface definitions)
   
   Why First:
   - Zero production dependencies
   - Smallest scope - pure type definitions
   - Standard build pattern (ESM + CJS)
   - Includes API extraction and type tests
   - Perfect for validating basic Bazel setup
   
   Build Outputs:
   - lib/ (ESM)
   - dist/ (CommonJS)
   - *.d.ts (type definitions)
   - api-report/ (API documentation)
   
   Migration Effort: 2-3 hours
   Risk: LOW (isolated, no dependencies)
   Validation: Output comparison with fluid-build


PHASE 2: SINGLE DEPENDENCY (2-3 hours)
-------------------------------------------

2. @fluidframework/driver-definitions
   Location: packages/common/driver-definitions
   Dependencies: core-interfaces (workspace:~)
   Size: ~800-1200 LOC
   
   Why Second:
   - Introduces workspace dependency handling
   - Same dual-output pattern proven
   - Tests inter-package type resolution
   - Foundation for many other packages
   
   Key Testing:
   - Workspace dependency resolution
   - Transitive type declarations
   - ESM→ESM and CJS→CJS import chains
   
   Migration Effort: 2-3 hours
   Risk: LOW (builds on proven pattern)


PHASE 3: MULTI-DEPENDENCY CHAIN (3-4 hours)
-------------------------------------------

3. @fluidframework/container-definitions
   Location: packages/common/container-definitions
   Dependencies: core-interfaces, driver-definitions (workspace:~)
   Size: ~1200-1800 LOC
   
   Why Third:
   - Tests multi-level dependency chains
   - Validates transitive dependency handling
   - API extraction across dependency graph
   - Real-world complexity validation
   
   Key Testing:
   - Multi-level dependency chains
   - Parallel API extraction configs
   - Build ordering constraints
   - Type validation ordering
   
   Migration Effort: 3-4 hours
   Risk: MEDIUM (multi-dependency, API extraction)
   Validation: Full dependency graph testing


RATIONALE FOR OTHER PACKAGES:
====================================

NOT Recommended for PoC:
- @fluid-internal/client-utils: Too many external deps (base64-js, buffer, sha.js)
- @fluidframework/core-utils: Has benchmark suites (complicates build)
- Any DDS package: 10+ internal dependencies, complex chains
- Framework packages: Deep dependency chains (5+ levels)
- Service packages: Integration with external services


BUILD SYSTEM CHARACTERISTICS
================================================================================

fluid-build Features:
1. Task-based execution (directed graph)
2. Workspace-aware dependency resolution
3. Parallel multi-core execution
4. Incremental building
5. Automatic dependency tracking

Bazel Equivalent Features:
1. BUILD targets (ts_library, mocha_test, jest_test)
2. Workspace dependency rules
3. Native parallel execution
4. Content-based caching
5. Transitive dependency management

Relevant Build Patterns:
- Dual output compilation (ESM + CJS)
- API extraction as build step
- Type tests as validation
- Multiple test frameworks (Mocha + Jest)
- Coverage reporting


MIGRATION STRATEGY OUTLINE
================================================================================

Phase 1: PoC (2 days)
- Establish Bazel patterns for 3 foundation packages
- Validate ESM/CJS dual compilation
- Test workspace dependencies
- Confirm output equivalence

Phase 2: Expansion (1 week)
- Migrate 10-15 packages across categories
- Expand test coverage
- Validate complex dependency chains

Phase 3: Integration (2-4 weeks)
- Full monorepo migration
- Strangler pattern (parallel execution)
- Gradual replacement of fluid-build

Success Metrics:
✓ Identical build outputs
✓ All tests passing
✓ Build time ≤ current speed
✓ Deterministic builds
✓ Incremental builds working
✓ No manual intervention


KEY FILES & CONFIGURATIONS
================================================================================

Root Configuration Files:
- fluidBuild.config.cjs (build task definitions)
- _buildProject.config.cjs (repository layout)
- package.json (65+ root scripts)
- pnpm-workspace.yaml (workspace packages)
- tsconfig.json (TypeScript reference)
- biome.jsonc (code formatting)
- .dependency-cruiser.cjs (architecture rules)
- syncpack.config.cjs (dependency sync)
- .pnpmfile.cjs (pnpm hooks & patches)
- layerInfo.json (package layers)

Per-Package Configuration:
- package.json (scripts, dependencies, fluidBuild.tasks)
- tsconfig.json (ESM compilation)
- tsconfig.cjs.json (CommonJS compilation)
- src/test/tsconfig.json (test compilation)
- api-extractor/*.json (API extraction configs)
- .eslintrc.cjs (ESLint rules)
- biome.jsonc (Biome config override)
- .mocharc.cjs (Mocha test config)
- jest.config.js (Jest config)


ARCHITECTURE INSIGHTS
================================================================================

Layered Design:
1. Core Interfaces (type-only packages)
2. Definition Packages (interface + minimal implementation)
3. Implementation Packages (full functionality)
4. Utility Packages (cross-cutting concerns)

Type-First Approach:
- Heavy use of TypeScript interfaces
- Type validation as first-class concern
- API reports for semantic versioning
- Breaking change detection via api-extractor

Testing Strategy:
- Type tests for type-level compatibility
- Unit tests (mocha) for logic validation
- Integration tests for feature validation
- Browser tests (jest+puppeteer) for UI

Dependency Management:
- workspace:~ for tight version coupling
- Locked versions via pnpm-lock.yaml
- Patchable dependencies via .pnpmfile.cjs
- Good-fences for architectural boundaries


CHALLENGES FOR BAZEL MIGRATION
================================================================================

Technical Challenges:
1. Dual output compilation (lib/ ESM + dist/ CJS)
2. API extraction complexity (multiple configs per package)
3. Mixed test frameworks (Mocha + Jest + c8)
4. Large dependency tree (1.5MB pnpm-lock.yaml)
5. Type validation across chains

Organizational Challenges:
1. Deep dependency chains (5+ levels)
2. API extraction ordering requirements
3. Type validation dependencies
4. Breaking change tracking

Solutions Approach:
- Bazel's native support for multiple outputs
- Custom rules for API extraction
- Test framework abstraction layer
- Proper dependency specification
- Type declaration management


BAZEL RULES NEEDED
================================================================================

Core Rules:
- ts_library (TypeScript compilation)
  └─ With dual output support (ESM + CJS)
- ts_project (Direct TypeScript compilation)
- mocha_test (Mocha test execution)
- jest_test (Jest test execution)
- api_extractor (Microsoft API extraction)

Supporting Rules:
- genrule (General command execution)
- sh_test (Shell script testing)
- filegroup (File grouping)

Toolchain Setup:
- TypeScript compiler toolchain
- Node.js runtime toolchain
- pnpm package manager
- api-extractor integration


VALIDATION & TESTING APPROACH
================================================================================

Output Comparison:
- Byte-for-byte comparison of lib/ and dist/ outputs
- Type declaration validation
- API report comparison
- Test result equivalence

Test Execution:
- Same Mocha/Jest tests
- Same coverage requirements
- Same linting rules
- Same type validation

Performance Metrics:
- Build time comparison
- Incremental build efficiency
- Parallel execution scaling
- Cache effectiveness


FILES CREATED FOR ANALYSIS
================================================================================

1. MONOREPO_ANALYSIS.md (489 lines)
   - Complete project structure overview
   - Build system architecture
   - Dependency graph analysis
   - TypeScript configuration details
   - Test infrastructure overview
   - Linting & quality tools
   - Configuration file reference
   - PoC candidate selection rationale
   - Build system comparison (fluid-build vs Bazel)
   - Migration strategy recommendations

2. POC_PACKAGES.md (403 lines)
   - Detailed PoC package descriptions
   - Bazel BUILD file patterns
   - Migration timeline estimates
   - Validation criteria
   - Success metrics
   - Output comparison matrix
   - Implementation roadmap

3. EXPLORATION_SUMMARY.txt (this file)
   - Executive overview
   - Quick reference guide
   - Key findings summary


RECOMMENDATIONS FOR PoC START
================================================================================

Start Point: @fluidframework/core-interfaces
Reasoning: Zero dependencies, smallest scope, standard patterns

Timeline: 12-16 hours (~2 days)

Deliverables:
1. BUILD files for 3 packages
2. Bazel TypeScript rules (ESM + CJS)
3. API extraction integration
4. Test execution setup
5. Validation scripts
6. Migration documentation

Success Criteria:
- Identical outputs to fluid-build
- All tests passing
- Build time ≤ current system
- Deterministic, reproducible builds

Next Steps:
1. Set up Bazel environment
2. Create BUILD file for core-interfaces
3. Configure TypeScript rules
4. Run build and validate outputs
5. Execute tests
6. Move to phase 2


CONCLUSION
================================================================================

The FluidFramework monorepo is well-structured with:
- Clean package boundaries
- Consistent build patterns
- Clear architectural layers
- Comprehensive testing

The recommended 3-package PoC (core-interfaces, driver-definitions, 
container-definitions) provides:
- Isolated foundation layer testing
- Single dependency validation
- Multi-dependency chain validation
- 12-16 hour realistic timeline
- Low-to-medium risk progression

The monorepo is an EXCELLENT candidate for Bazel migration using the
strangler pattern (gradual package-by-package replacement).

================================================================================
